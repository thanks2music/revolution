/**
 * Slug Resolver Module
 *
 * Purpose:
 *   - Provide domain-specific slug resolution functions
 *   - Abstract YAML config access with clean API
 *   - Support MVP Phase 0.1 canonicalKey generation
 *   - Implement fallback chain (YAML ‚Üí Claude ‚Üí ASCII)
 *
 * @module lib/config/slug-resolver
 * @see {@link /notes/02-backlog/super-mvp-scope.md} for specification
 */

import { loadYamlConfig } from './yaml-loader';
import { generateSlugWithFallback } from './slug-generator';
import type { CostTrackerService } from '@/lib/ai/cost';

/**
 * Resolves a Japanese anime/manga title to its romaji slug
 *
 * @description
 * Looks up the title in title-romaji-mapping.yaml
 * If not found in YAML, uses fallback chain: Claude API ‚Üí ASCII slugify
 * Used for URL construction: /collabo-cafe/{work-slug}/...
 *
 * @param {string} japaneseTitle - Japanese title (e.g., "‰ΩúÂìÅÂêç")
 * @param {boolean} enableFallback - Enable fallback to Claude API + ASCII (default: true)
 * @param {CostTrackerService} costTracker - Optional cost tracker for recording API usage
 * @returns {Promise<string | null>} Romaji slug (e.g., "sample-work") or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * // With YAML match
 * const slug = await resolveWorkSlug("‰ΩúÂìÅÂêç");
 * console.log(slug); // "work-slug" (from YAML)
 *
 * // Without YAML match, fallback to Claude
 * const slug2 = await resolveWorkSlug("Êñ∞‰Ωú„Ç¢„Éã„É°");
 * console.log(slug2); // "shinsaku-anime" (generated by Claude)
 *
 * // Disable fallback (YAML only)
 * const slug3 = await resolveWorkSlug("Unknown", false);
 * console.log(slug3); // null
 * ```
 */
export async function resolveWorkSlug(
  japaneseTitle: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  // Try YAML first
  const config = loadYamlConfig('TITLE_ROMAJI');
  const yamlSlug = config.titles[japaneseTitle];

  if (yamlSlug) {
    console.log(
      `[Slug Resolver] ‚úÖ Work slug found in YAML: "${japaneseTitle}" ‚Üí "${yamlSlug}"`
    );
    return yamlSlug;
  }

  // If not found and fallback enabled, use fallback chain
  if (enableFallback) {
    console.log(
      `[Slug Resolver] ‚ö†Ô∏è Work slug not in YAML: "${japaneseTitle}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        japaneseTitle,
        'anime/manga title',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] ‚ùå Fallback failed for "${japaneseTitle}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves a brand/store name to its slug
 *
 * @description
 * Looks up the brand in brand-slugs.yaml
 * If not found in YAML, uses fallback chain: Claude API ‚Üí ASCII slugify
 * Used for canonicalKey: {workSlug}:{storeSlug}:{eventType}:{year}
 *
 * @param {string} brandName - Brand name (e.g., "„Ç¢„Éô„Ç§„É´", "„Åó„Åæ„ÇÄ„Çâ")
 * @param {boolean} enableFallback - Enable fallback to Claude API + ASCII (default: true)
 * @returns {Promise<string | null>} Brand slug (e.g., "avail", "shimamura") or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * // With YAML match
 * const slug = await resolveStoreSlug("„Ç¢„Éô„Ç§„É´");
 * console.log(slug); // "avail" (from YAML)
 *
 * // Without YAML match, fallback to Claude
 * const slug2 = await resolveStoreSlug("Êñ∞Â∫óËàó");
 * console.log(slug2); // "shin-tenpo" (generated by Claude)
 *
 * // Disable fallback (YAML only)
 * const slug3 = await resolveStoreSlug("Unknown", false);
 * console.log(slug3); // null
 * ```
 */
export async function resolveStoreSlug(
  brandName: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  // Try YAML first
  const config = loadYamlConfig('BRAND_SLUGS');
  const yamlSlug = config.brand_slugs[brandName];

  if (yamlSlug) {
    console.log(
      `[Slug Resolver] ‚úÖ Store slug found in YAML: "${brandName}" ‚Üí "${yamlSlug}"`
    );
    return yamlSlug;
  }

  // If not found and fallback enabled, use fallback chain
  if (enableFallback) {
    console.log(
      `[Slug Resolver] ‚ö†Ô∏è Store slug not in YAML: "${brandName}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        brandName,
        'store/brand name',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] ‚ùå Fallback failed for "${brandName}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves an event type name to its canonical slug
 *
 * @description
 * Looks up the event type in event-type-slugs.yaml
 * Handles synonyms (e.g., "„Ç≥„É©„Éú„Ç´„Éï„Çß" and "„Ç´„Éï„Çß„Ç≥„É©„Éú" both map to "collabo-cafe")
 * If not found in YAML, uses fallback chain: Claude API ‚Üí ASCII slugify
 *
 * @param {string} eventTypeName - Event type name (e.g., "„Ç≥„É©„Éú„Ç´„Éï„Çß", "„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çπ„Éà„Ç¢")
 * @param {boolean} enableFallback - Enable fallback to Claude API + ASCII (default: true)
 * @returns {Promise<string | null>} Event type slug (e.g., "collabo-cafe", "pop-up-store") or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * // With YAML match (including synonyms)
 * const slug1 = await resolveEventTypeSlug("„Ç≥„É©„Éú„Ç´„Éï„Çß");
 * const slug2 = await resolveEventTypeSlug("„Ç´„Éï„Çß„Ç≥„É©„Éú");
 * console.log(slug1 === slug2); // true (both return "collabo-cafe")
 *
 * // Without YAML match, fallback to Claude
 * const slug3 = await resolveEventTypeSlug("Êñ∞„Ç§„Éô„É≥„Éà");
 * console.log(slug3); // "shin-ibento" (generated by Claude)
 *
 * // Disable fallback (YAML only)
 * const slug4 = await resolveEventTypeSlug("Unknown", false);
 * console.log(slug4); // null
 * ```
 */
export async function resolveEventTypeSlug(
  eventTypeName: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  // Try YAML first
  const config = loadYamlConfig('EVENT_TYPE_SLUGS');
  const yamlSlug = config.event_types[eventTypeName];

  if (yamlSlug) {
    console.log(
      `[Slug Resolver] ‚úÖ Event type slug found in YAML: "${eventTypeName}" ‚Üí "${yamlSlug}"`
    );
    return yamlSlug;
  }

  // If not found and fallback enabled, use fallback chain
  if (enableFallback) {
    console.log(
      `[Slug Resolver] ‚ö†Ô∏è Event type slug not in YAML: "${eventTypeName}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        eventTypeName,
        'event type',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] ‚ùå Fallback failed for "${eventTypeName}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves a prefecture name to its slug
 *
 * @description
 * Looks up the prefecture in jp-prefecture.yaml
 * Handles variants (e.g., "Êù±‰∫¨ÈÉΩ", "Êù±‰∫¨", "ÈÉΩ" all map to "tokyo")
 * Note: Phase 0.1 does not use prefecture slugs, but this is prepared for Phase 1+
 *
 * @param {string} prefectureName - Prefecture name (e.g., "Êù±‰∫¨ÈÉΩ", "Â§ßÈò™Â∫ú")
 * @returns {string | null} Prefecture slug (e.g., "tokyo", "osaka") or null if not found
 *
 * @example
 * ```typescript
 * const slug1 = resolvePrefectureSlug("Êù±‰∫¨ÈÉΩ");
 * const slug2 = resolvePrefectureSlug("Êù±‰∫¨");
 * const slug3 = resolvePrefectureSlug("ÈÉΩ");
 * console.log(slug1 === slug2 && slug2 === slug3); // true (all return "tokyo")
 * ```
 */
export function resolvePrefectureSlug(prefectureName: string): string | null {
  const config = loadYamlConfig('JP_PREFECTURE');
  return config.prefectures[prefectureName] || null;
}

/**
 * Resolves an array of prefecture names to their slugs
 *
 * @description
 * Batch version of resolvePrefectureSlug for Phase 1+ areas axis support.
 * Handles multiple prefectures from multi-location events.
 * Invalid prefecture names are filtered out.
 *
 * @param {string[]} prefectureNames - Array of prefecture names (e.g., ["Êù±‰∫¨ÈÉΩ", "Â§ßÈò™Â∫ú"])
 * @returns {{ prefectures: string[], slugs: string[] }} Object with resolved prefectures and slugs
 *
 * @see taxonomy.yaml axes.areas
 *
 * @example
 * ```typescript
 * const result = resolvePrefectureSlugs(["Êù±‰∫¨ÈÉΩ", "Â§ßÈò™Â∫ú", "UnknownCity"]);
 * console.log(result);
 * // {
 * //   prefectures: ["Êù±‰∫¨ÈÉΩ", "Â§ßÈò™Â∫ú"],  // Only valid ones
 * //   slugs: ["tokyo", "osaka"]
 * // }
 * ```
 */
export function resolvePrefectureSlugs(prefectureNames: string[]): {
  prefectures: string[];
  slugs: string[];
} {
  const config = loadYamlConfig('JP_PREFECTURE');

  const resolvedPrefectures: string[] = [];
  const resolvedSlugs: string[] = [];

  for (const name of prefectureNames) {
    const slug = config.prefectures[name];
    if (slug) {
      // Only include if slug is found and not already in the list
      if (!resolvedSlugs.includes(slug)) {
        resolvedPrefectures.push(name);
        resolvedSlugs.push(slug);
      }
    } else {
      console.warn(
        `[Slug Resolver] ‚ö†Ô∏è Prefecture not found in YAML: "${name}". Skipping.`
      );
    }
  }

  console.log(
    `[Slug Resolver] üìç Resolved ${resolvedPrefectures.length}/${prefectureNames.length} prefectures: ` +
      `[${resolvedPrefectures.join(', ')}] ‚Üí [${resolvedSlugs.join(', ')}]`
  );

  return {
    prefectures: resolvedPrefectures,
    slugs: resolvedSlugs,
  };
}

/**
 * Resolves a city name to its slug
 *
 * @description
 * Looks up the city in jp-prefecture.yaml major_cities section
 * Note: Phase 0.1 does not use city slugs, prepared for future use
 *
 * @param {string} cityName - City name (e.g., "Êñ∞ÂÆø", "Ê∏ãË∞∑")
 * @returns {string | null} City slug (e.g., "shinjuku", "shibuya") or null if not found
 *
 * @example
 * ```typescript
 * const slug = resolveCitySlug("Êñ∞ÂÆø");
 * console.log(slug); // "shinjuku"
 * ```
 */
export function resolveCitySlug(cityName: string): string | null {
  const config = loadYamlConfig('JP_PREFECTURE');
  return config.major_cities?.[cityName] || null;
}

/**
 * Gets all available work titles
 *
 * @description
 * Returns all Japanese titles from the config
 * Useful for validation or autocomplete features
 *
 * @returns {string[]} Array of Japanese titles
 *
 * @example
 * ```typescript
 * const titles = getAllWorkTitles();
 * console.log(titles); // ["‰ΩúÂìÅÂêç", "Âà•‰ΩúÂìÅ", ...]
 * ```
 */
export function getAllWorkTitles(): string[] {
  const config = loadYamlConfig('TITLE_ROMAJI');
  return Object.keys(config.titles);
}

/**
 * Gets all available brand names
 *
 * @description
 * Returns all brand names from the config
 *
 * @returns {string[]} Array of brand names
 *
 * @example
 * ```typescript
 * const brands = getAllBrandNames();
 * console.log(brands); // ["„Ç¢„Éô„Ç§„É´", "„Åó„Åæ„ÇÄ„Çâ", ...]
 * ```
 */
export function getAllBrandNames(): string[] {
  const config = loadYamlConfig('BRAND_SLUGS');
  return Object.keys(config.brand_slugs);
}

/**
 * Gets all available event type names
 *
 * @description
 * Returns all event type names (including synonyms) from the config
 *
 * @returns {string[]} Array of event type names
 *
 * @example
 * ```typescript
 * const types = getAllEventTypeNames();
 * console.log(types); // ["„Ç≥„É©„Éú„Ç´„Éï„Çß", "„Ç´„Éï„Çß„Ç≥„É©„Éú", "„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çπ„Éà„Ç¢", ...]
 * ```
 */
export function getAllEventTypeNames(): string[] {
  const config = loadYamlConfig('EVENT_TYPE_SLUGS');
  return Object.keys(config.event_types);
}

/**
 * Gets all available prefecture names
 *
 * @description
 * Returns all prefecture names (including variants) from the config
 *
 * @returns {string[]} Array of prefecture names
 *
 * @example
 * ```typescript
 * const prefectures = getAllPrefectureNames();
 * console.log(prefectures); // ["Êù±‰∫¨ÈÉΩ", "Êù±‰∫¨", "ÈÉΩ", "Â§ßÈò™Â∫ú", ...]
 * ```
 */
export function getAllPrefectureNames(): string[] {
  const config = loadYamlConfig('JP_PREFECTURE');
  return Object.keys(config.prefectures);
}

/**
 * Validates if a work title exists in the config
 *
 * @param {string} japaneseTitle - Japanese title to validate
 * @returns {boolean} True if title exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidWorkTitle("‰ΩúÂìÅÂêç")); // true
 * console.log(isValidWorkTitle("Unknown")); // false
 * ```
 */
export function isValidWorkTitle(japaneseTitle: string): boolean {
  return resolveWorkSlug(japaneseTitle) !== null;
}

/**
 * Validates if a brand name exists in the config
 *
 * @param {string} brandName - Brand name to validate
 * @returns {boolean} True if brand exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidBrandName("„Ç¢„Éô„Ç§„É´")); // true
 * console.log(isValidBrandName("Unknown")); // false
 * ```
 */
export function isValidBrandName(brandName: string): boolean {
  return resolveStoreSlug(brandName) !== null;
}

/**
 * Validates if an event type name exists in the config
 *
 * @param {string} eventTypeName - Event type name to validate
 * @returns {boolean} True if event type exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidEventTypeName("„Ç≥„É©„Éú„Ç´„Éï„Çß")); // true
 * console.log(isValidEventTypeName("Unknown")); // false
 * ```
 */
export function isValidEventTypeName(eventTypeName: string): boolean {
  return resolveEventTypeSlug(eventTypeName) !== null;
}
