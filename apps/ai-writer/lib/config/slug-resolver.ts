/**
 * Slug Resolver Module
 *
 * Purpose:
 *   - Provide domain-specific slug resolution functions
 *   - Abstract YAML config access with clean API
 *   - Support MVP Phase 0.1 canonicalKey generation
 *   - Implement fallback chain (YAML â†’ Claude â†’ ASCII)
 *
 * @module lib/config/slug-resolver
 * @see {@link /notes/02-backlog/super-mvp-scope.md} for specification
 */

import { loadYamlConfig } from './yaml-loader';
import { generateSlugWithFallback } from './slug-generator';
import type { CostTrackerService } from '@/lib/ai/cost';
import type { TitleEntry } from './types';

// ============================================================================
// Type Guards and Helper Functions
// ============================================================================

/**
 * Type guard: TitleEntry ã‹ã©ã†ã‹ã‚’åˆ¤å®š
 *
 * @param value - string ã¾ãŸã¯ TitleEntry
 * @returns TitleEntry ã®å ´åˆ true
 */
function isTitleEntry(value: string | TitleEntry): value is TitleEntry {
  return typeof value === 'object' && value !== null && 'slug' in value;
}

/**
 * string | TitleEntry ã‹ã‚‰ã‚¹ãƒ©ã‚°ã‚’æŠ½å‡º
 *
 * @param value - string ã¾ãŸã¯ TitleEntry
 * @returns ã‚¹ãƒ©ã‚°æ–‡å­—åˆ—
 */
function extractSlug(value: string | TitleEntry): string {
  return isTitleEntry(value) ? value.slug : value;
}

/**
 * Resolves a Japanese anime/manga title to its romaji slug
 *
 * @description
 * Resolution order:
 * 1. Direct match in YAML (main title)
 * 2. Alias match in YAML (variants/abbreviations)
 * 3. Fallback chain: AI API â†’ ASCII slugify
 *
 * Used for URL construction: /collabo-cafe/{work-slug}/...
 *
 * @param {string} japaneseTitle - Japanese title (e.g., "é€²æ’ƒã®å·¨äºº", "ãƒªã‚¼ãƒ­")
 * @param {boolean} enableFallback - Enable fallback to AI API + ASCII (default: true)
 * @param {CostTrackerService} costTracker - Optional cost tracker for recording API usage
 * @returns {Promise<string | null>} Romaji slug or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * await resolveWorkSlug("é€²æ’ƒã®å·¨äºº");  // â†’ "attack-on-titan" (direct match)
 * await resolveWorkSlug("ãƒªã‚¼ãƒ­");      // â†’ "rezero" (alias match)
 * await resolveWorkSlug("æ–°ä½œã‚¢ãƒ‹ãƒ¡");  // â†’ "shinsaku-anime" (fallback)
 * await resolveWorkSlug("Unknown", false); // â†’ null (fallback disabled)
 * ```
 */
export async function resolveWorkSlug(
  japaneseTitle: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  const config = loadYamlConfig('TITLE_ROMAJI');

  // 1. ç›´æ¥ãƒãƒƒãƒï¼ˆãƒ¡ã‚¤ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ï¼‰
  const directMatch = config.titles[japaneseTitle];
  if (directMatch) {
    const slug = extractSlug(directMatch);
    console.log(
      `[Slug Resolver] âœ… Work slug found in YAML: "${japaneseTitle}" â†’ "${slug}"`
    );
    return slug;
  }

  // 2. ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ¤œç´¢ï¼ˆè¡¨è¨˜ã‚†ã‚Œãƒ»ç•¥ç§°å¯¾å¿œï¼‰
  for (const [title, value] of Object.entries(config.titles)) {
    if (isTitleEntry(value) && value.aliases?.includes(japaneseTitle)) {
      console.log(
        `[Slug Resolver] âœ… Work slug found via alias: "${japaneseTitle}" â†’ "${title}" â†’ "${value.slug}"`
      );
      return value.slug;
    }
  }

  // 3. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆAI â†’ ASCII slugifyï¼‰
  if (enableFallback) {
    console.log(
      `[Slug Resolver] âš ï¸ Work slug not in YAML: "${japaneseTitle}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        japaneseTitle,
        'anime/manga title',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] âŒ Fallback failed for "${japaneseTitle}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves a brand/store name to its slug
 *
 * @description
 * Looks up the brand in brand-slugs.yaml
 * If not found in YAML, uses fallback chain: Claude API â†’ ASCII slugify
 * Used for canonicalKey: {workSlug}:{storeSlug}:{eventType}:{year}
 *
 * @param {string} brandName - Brand name (e.g., "ã‚¢ãƒ™ã‚¤ãƒ«", "ã—ã¾ã‚€ã‚‰")
 * @param {boolean} enableFallback - Enable fallback to Claude API + ASCII (default: true)
 * @returns {Promise<string | null>} Brand slug (e.g., "avail", "shimamura") or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * // With YAML match
 * const slug = await resolveStoreSlug("ã‚¢ãƒ™ã‚¤ãƒ«");
 * console.log(slug); // "avail" (from YAML)
 *
 * // Without YAML match, fallback to Claude
 * const slug2 = await resolveStoreSlug("æ–°åº—èˆ—");
 * console.log(slug2); // "shin-tenpo" (generated by Claude)
 *
 * // Disable fallback (YAML only)
 * const slug3 = await resolveStoreSlug("Unknown", false);
 * console.log(slug3); // null
 * ```
 */
export async function resolveStoreSlug(
  brandName: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  // Try YAML first
  const config = loadYamlConfig('BRAND_SLUGS');
  const yamlSlug = config.brand_slugs[brandName];

  if (yamlSlug) {
    console.log(
      `[Slug Resolver] âœ… Store slug found in YAML: "${brandName}" â†’ "${yamlSlug}"`
    );
    return yamlSlug;
  }

  // If not found and fallback enabled, use fallback chain
  if (enableFallback) {
    console.log(
      `[Slug Resolver] âš ï¸ Store slug not in YAML: "${brandName}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        brandName,
        'store/brand name',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] âŒ Fallback failed for "${brandName}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves an event type name to its canonical slug
 *
 * @description
 * Looks up the event type in event-type-slugs.yaml
 * Handles synonyms (e.g., "ã‚³ãƒ©ãƒœã‚«ãƒ•ã‚§" and "ã‚«ãƒ•ã‚§ã‚³ãƒ©ãƒœ" both map to "collabo-cafe")
 * If not found in YAML, uses fallback chain: Claude API â†’ ASCII slugify
 *
 * @param {string} eventTypeName - Event type name (e.g., "ã‚³ãƒ©ãƒœã‚«ãƒ•ã‚§", "ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¹ãƒˆã‚¢")
 * @param {boolean} enableFallback - Enable fallback to Claude API + ASCII (default: true)
 * @returns {Promise<string | null>} Event type slug (e.g., "collabo-cafe", "pop-up-store") or null if not found and fallback disabled
 *
 * @example
 * ```typescript
 * // With YAML match (including synonyms)
 * const slug1 = await resolveEventTypeSlug("ã‚³ãƒ©ãƒœã‚«ãƒ•ã‚§");
 * const slug2 = await resolveEventTypeSlug("ã‚«ãƒ•ã‚§ã‚³ãƒ©ãƒœ");
 * console.log(slug1 === slug2); // true (both return "collabo-cafe")
 *
 * // Without YAML match, fallback to Claude
 * const slug3 = await resolveEventTypeSlug("æ–°ã‚¤ãƒ™ãƒ³ãƒˆ");
 * console.log(slug3); // "shin-ibento" (generated by Claude)
 *
 * // Disable fallback (YAML only)
 * const slug4 = await resolveEventTypeSlug("Unknown", false);
 * console.log(slug4); // null
 * ```
 */
export async function resolveEventTypeSlug(
  eventTypeName: string,
  enableFallback = true,
  costTracker?: CostTrackerService
): Promise<string | null> {
  // Try YAML first
  const config = loadYamlConfig('EVENT_TYPE_SLUGS');
  const yamlSlug = config.event_types[eventTypeName];

  if (yamlSlug) {
    console.log(
      `[Slug Resolver] âœ… Event type slug found in YAML: "${eventTypeName}" â†’ "${yamlSlug}"`
    );
    return yamlSlug;
  }

  // If not found and fallback enabled, use fallback chain
  if (enableFallback) {
    console.log(
      `[Slug Resolver] âš ï¸ Event type slug not in YAML: "${eventTypeName}". Trying fallback...`
    );
    try {
      const fallbackSlug = await generateSlugWithFallback(
        eventTypeName,
        'event type',
        costTracker
      );
      return fallbackSlug;
    } catch (error) {
      console.error(
        `[Slug Resolver] âŒ Fallback failed for "${eventTypeName}":`,
        error instanceof Error ? error.message : String(error)
      );
      return null;
    }
  }

  return null;
}

/**
 * Resolves a prefecture name to its slug
 *
 * @description
 * Looks up the prefecture in jp-prefecture.yaml
 * Handles variants (e.g., "æ±äº¬éƒ½", "æ±äº¬", "éƒ½" all map to "tokyo")
 * Note: Phase 0.1 does not use prefecture slugs, but this is prepared for Phase 1+
 *
 * @param {string} prefectureName - Prefecture name (e.g., "æ±äº¬éƒ½", "å¤§é˜ªåºœ")
 * @returns {string | null} Prefecture slug (e.g., "tokyo", "osaka") or null if not found
 *
 * @example
 * ```typescript
 * const slug1 = resolvePrefectureSlug("æ±äº¬éƒ½");
 * const slug2 = resolvePrefectureSlug("æ±äº¬");
 * const slug3 = resolvePrefectureSlug("éƒ½");
 * console.log(slug1 === slug2 && slug2 === slug3); // true (all return "tokyo")
 * ```
 */
export function resolvePrefectureSlug(prefectureName: string): string | null {
  const config = loadYamlConfig('JP_PREFECTURE');
  return config.prefectures[prefectureName] || null;
}

/**
 * Resolves an array of prefecture names to their slugs
 *
 * @description
 * Batch version of resolvePrefectureSlug for Phase 1+ areas axis support.
 * Handles multiple prefectures from multi-location events.
 * Invalid prefecture names are filtered out.
 *
 * @param {string[]} prefectureNames - Array of prefecture names (e.g., ["æ±äº¬éƒ½", "å¤§é˜ªåºœ"])
 * @returns {{ prefectures: string[], slugs: string[] }} Object with resolved prefectures and slugs
 *
 * @see taxonomy.yaml axes.areas
 *
 * @example
 * ```typescript
 * const result = resolvePrefectureSlugs(["æ±äº¬éƒ½", "å¤§é˜ªåºœ", "UnknownCity"]);
 * console.log(result);
 * // {
 * //   prefectures: ["æ±äº¬éƒ½", "å¤§é˜ªåºœ"],  // Only valid ones
 * //   slugs: ["tokyo", "osaka"]
 * // }
 * ```
 */
export function resolvePrefectureSlugs(prefectureNames: string[]): {
  prefectures: string[];
  slugs: string[];
} {
  const config = loadYamlConfig('JP_PREFECTURE');

  const resolvedPrefectures: string[] = [];
  const resolvedSlugs: string[] = [];

  for (const name of prefectureNames) {
    const slug = config.prefectures[name];
    if (slug) {
      // Only include if slug is found and not already in the list
      if (!resolvedSlugs.includes(slug)) {
        resolvedPrefectures.push(name);
        resolvedSlugs.push(slug);
      }
    } else {
      console.warn(
        `[Slug Resolver] âš ï¸ Prefecture not found in YAML: "${name}". Skipping.`
      );
    }
  }

  console.log(
    `[Slug Resolver] ğŸ“ Resolved ${resolvedPrefectures.length}/${prefectureNames.length} prefectures: ` +
      `[${resolvedPrefectures.join(', ')}] â†’ [${resolvedSlugs.join(', ')}]`
  );

  return {
    prefectures: resolvedPrefectures,
    slugs: resolvedSlugs,
  };
}

/**
 * Resolves a city name to its slug
 *
 * @description
 * Looks up the city in jp-prefecture.yaml major_cities section
 * Note: Phase 0.1 does not use city slugs, prepared for future use
 *
 * @param {string} cityName - City name (e.g., "æ–°å®¿", "æ¸‹è°·")
 * @returns {string | null} City slug (e.g., "shinjuku", "shibuya") or null if not found
 *
 * @example
 * ```typescript
 * const slug = resolveCitySlug("æ–°å®¿");
 * console.log(slug); // "shinjuku"
 * ```
 */
export function resolveCitySlug(cityName: string): string | null {
  const config = loadYamlConfig('JP_PREFECTURE');
  return config.major_cities?.[cityName] || null;
}

/**
 * Gets all available work titles
 *
 * @description
 * Returns all Japanese titles from the config
 * Useful for validation or autocomplete features
 *
 * @returns {string[]} Array of Japanese titles
 *
 * @example
 * ```typescript
 * const titles = getAllWorkTitles();
 * console.log(titles); // ["ä½œå“å", "åˆ¥ä½œå“", ...]
 * ```
 */
export function getAllWorkTitles(): string[] {
  const config = loadYamlConfig('TITLE_ROMAJI');
  return Object.keys(config.titles);
}

/**
 * Gets all available brand names
 *
 * @description
 * Returns all brand names from the config
 *
 * @returns {string[]} Array of brand names
 *
 * @example
 * ```typescript
 * const brands = getAllBrandNames();
 * console.log(brands); // ["ã‚¢ãƒ™ã‚¤ãƒ«", "ã—ã¾ã‚€ã‚‰", ...]
 * ```
 */
export function getAllBrandNames(): string[] {
  const config = loadYamlConfig('BRAND_SLUGS');
  return Object.keys(config.brand_slugs);
}

/**
 * Gets all available event type names
 *
 * @description
 * Returns all event type names (including synonyms) from the config
 *
 * @returns {string[]} Array of event type names
 *
 * @example
 * ```typescript
 * const types = getAllEventTypeNames();
 * console.log(types); // ["ã‚³ãƒ©ãƒœã‚«ãƒ•ã‚§", "ã‚«ãƒ•ã‚§ã‚³ãƒ©ãƒœ", "ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¹ãƒˆã‚¢", ...]
 * ```
 */
export function getAllEventTypeNames(): string[] {
  const config = loadYamlConfig('EVENT_TYPE_SLUGS');
  return Object.keys(config.event_types);
}

/**
 * Gets all available prefecture names
 *
 * @description
 * Returns all prefecture names (including variants) from the config
 *
 * @returns {string[]} Array of prefecture names
 *
 * @example
 * ```typescript
 * const prefectures = getAllPrefectureNames();
 * console.log(prefectures); // ["æ±äº¬éƒ½", "æ±äº¬", "éƒ½", "å¤§é˜ªåºœ", ...]
 * ```
 */
export function getAllPrefectureNames(): string[] {
  const config = loadYamlConfig('JP_PREFECTURE');
  return Object.keys(config.prefectures);
}

/**
 * Validates if a work title exists in the config
 *
 * @param {string} japaneseTitle - Japanese title to validate
 * @returns {boolean} True if title exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidWorkTitle("ä½œå“å")); // true
 * console.log(isValidWorkTitle("Unknown")); // false
 * ```
 */
export function isValidWorkTitle(japaneseTitle: string): boolean {
  return resolveWorkSlug(japaneseTitle) !== null;
}

/**
 * Validates if a brand name exists in the config
 *
 * @param {string} brandName - Brand name to validate
 * @returns {boolean} True if brand exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidBrandName("ã‚¢ãƒ™ã‚¤ãƒ«")); // true
 * console.log(isValidBrandName("Unknown")); // false
 * ```
 */
export function isValidBrandName(brandName: string): boolean {
  return resolveStoreSlug(brandName) !== null;
}

/**
 * Validates if an event type name exists in the config
 *
 * @param {string} eventTypeName - Event type name to validate
 * @returns {boolean} True if event type exists in config
 *
 * @example
 * ```typescript
 * console.log(isValidEventTypeName("ã‚³ãƒ©ãƒœã‚«ãƒ•ã‚§")); // true
 * console.log(isValidEventTypeName("Unknown")); // false
 * ```
 */
export function isValidEventTypeName(eventTypeName: string): boolean {
  return resolveEventTypeSlug(eventTypeName) !== null;
}

// ============================================================================
// Title Metadata Functions (i18n/Phase2 å‘ã‘)
// ============================================================================

/**
 * Get official English title for a Japanese title
 *
 * @description
 * Looks up english_title field in TitleEntry.
 * Supports both direct title match and alias lookup.
 * Useful for i18n support in Phase2.
 *
 * @param {string} japaneseTitle - Japanese title or alias
 * @returns {string | null} English title or null if not found
 *
 * @example
 * ```typescript
 * getEnglishTitle("é€²æ’ƒã®å·¨äºº");      // â†’ "Attack on Titan"
 * getEnglishTitle("ãƒªã‚¼ãƒ­");          // â†’ "Re:Zero - Starting Life in Another World"
 * getEnglishTitle("çœŸãƒ»ä¾ä¼ YAIBA"); // â†’ null (simple entry, no english_title)
 * ```
 */
export function getEnglishTitle(japaneseTitle: string): string | null {
  const config = loadYamlConfig('TITLE_ROMAJI');

  // ç›´æ¥ãƒãƒƒãƒ
  const directMatch = config.titles[japaneseTitle];
  if (directMatch && isTitleEntry(directMatch)) {
    return directMatch.english_title || null;
  }

  // ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‹ã‚‰ã‚‚æ¤œç´¢
  for (const [, value] of Object.entries(config.titles)) {
    if (isTitleEntry(value) && value.aliases?.includes(japaneseTitle)) {
      return value.english_title || null;
    }
  }

  return null;
}

/**
 * Find canonical (main) title from alias or direct match
 *
 * @description
 * Given an alias or main title, returns the canonical Japanese title.
 * Useful for normalization and deduplication.
 *
 * @param {string} aliasOrTitle - Alias or main title to look up
 * @returns {string | null} Canonical Japanese title or null if not found
 *
 * @example
 * ```typescript
 * findCanonicalTitle("ãƒªã‚¼ãƒ­");           // â†’ "Re:ã‚¼ãƒ­ã‹ã‚‰å§‹ã‚ã‚‹ç•°ä¸–ç•Œç”Ÿæ´»"
 * findCanonicalTitle("é€²æ’ƒã®å·¨äºº");       // â†’ "é€²æ’ƒã®å·¨äºº" (already canonical)
 * findCanonicalTitle("å­˜åœ¨ã—ãªã„ä½œå“");   // â†’ null
 * ```
 */
export function findCanonicalTitle(aliasOrTitle: string): string | null {
  const config = loadYamlConfig('TITLE_ROMAJI');

  // ç›´æ¥ãƒãƒƒãƒï¼ˆæ—¢ã«æ­£è¦ã‚¿ã‚¤ãƒˆãƒ«ï¼‰
  if (config.titles[aliasOrTitle]) {
    return aliasOrTitle;
  }

  // ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ¤œç´¢
  for (const [title, value] of Object.entries(config.titles)) {
    if (isTitleEntry(value) && value.aliases?.includes(aliasOrTitle)) {
      return title;
    }
  }

  return null;
}
